from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
try:
    from pydantic import EmailStr
except ImportError:
    # Fallback if email_validator not available
    EmailStr = str
from typing import Optional
from sqlalchemy.orm import Session
from datetime import datetime

from app.database import get_db
from app.models import ThreatDetection, ThreatReport

router = APIRouter()


class CreateReportRequest(BaseModel):
    threat_id: int
    reporter_contact: Optional[str] = None
    additional_details: Optional[str] = None
    is_urgent: bool = False


class ReportResponse(BaseModel):
    id: int
    threat_id: int
    status: str
    reported_at: datetime
    cybercrime_reference: Optional[str]


@router.post("/create", response_model=ReportResponse)
async def create_threat_report(
    request: CreateReportRequest,
    db: Session = Depends(get_db)
):
    """
    Create a new threat report for cybercrime.gov.in submission
    """
    try:
        # Verify threat exists
        threat = db.query(ThreatDetection).filter(
            ThreatDetection.id == request.threat_id
        ).first()
        
        if not threat:
            raise HTTPException(status_code=404, detail="Threat not found")
        
        # Create report record
        report = ThreatReport(
            threat_id=request.threat_id,
            reporter_contact=request.reporter_contact,
            additional_details=request.additional_details,
            is_urgent=request.is_urgent,
            reported_at=datetime.now(),
            cybercrime_reference=f"AICMS_{datetime.now().strftime('%Y%m%d')}_{request.threat_id:06d}",
            status="submitted"
        )
        
        db.add(report)
        
        # Mark threat as reported
        threat.is_reported = True
        
        db.commit()
        db.refresh(report)
        
        return ReportResponse(
            id=report.id,
            threat_id=report.threat_id,
            status=report.status,
            reported_at=report.reported_at,
            cybercrime_reference=report.cybercrime_reference
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating report: {str(e)}")


@router.get("/generate/{threat_id}")
async def generate_report_content(threat_id: int, db: Session = Depends(get_db)):
    """
    Generate formatted report content for cybercrime.gov.in submission
    """
    try:
        threat = db.query(ThreatDetection).filter(
            ThreatDetection.id == threat_id
        ).first()
        
        if not threat:
            raise HTTPException(status_code=404, detail="Threat not found")
        
        # Generate comprehensive report content
        report_content = f"""
CYBERCRIME REPORT - Aatra AI AICMS
=====================================

THREAT IDENTIFICATION:
Reference ID: AICMS_{datetime.now().strftime('%Y%m%d')}_{threat_id:06d}
Detection Time: {threat.detected_at.strftime('%Y-%m-%d %H:%M:%S')} IST
Threat Level: {threat.threat_type.upper()}
Confidence Score: {threat.confidence}%

PLATFORM DETAILS:
Platform: {threat.platform}
Source URL: {threat.source_url or 'Not available'}
User Handle: {threat.user_handle or 'Not available'}
Geographic Region: {threat.region or 'Online'}

CONTENT ANALYSIS:
Title: {threat.title}

Original Content:
{threat.content}

THREAT ASSESSMENT:
{threat.analysis_result.get('summary') if threat.analysis_result else 'Detailed analysis indicates potential anti-India content requiring investigation.'}

DETECTED INDICATORS:
{chr(10).join(['• ' + indicator for indicator in (threat.analysis_result.get('indicators', []) if threat.analysis_result else ['Anti-India content detected', 'Requires manual review'])]) }

RECOMMENDED ACTION:
{threat.analysis_result.get('recommendedAction') if threat.analysis_result else 'Investigation and appropriate action recommended based on content analysis.'}

SYSTEM INFORMATION:
Detection System: Aatra AI - Anti-India Campaign Monitoring System (AICMS)
ML Model Version: v2.4.1
Analysis Method: Automated hate speech detection with manual verification
Reporting Authority: Cybersecurity Operations Center

VERIFICATION STATUS:
Automated Detection: ✓ Completed
Manual Review: {'✓ Verified' if threat.is_verified else '⚠ Pending'}
Report Status: {'✓ Previously Reported' if threat.is_reported else '• First Report'}

CONTACT INFORMATION:
System Administrator: AICMS Operations Team
Technical Support: Available for law enforcement coordination
Integration: Direct API connectivity with cybercrime.gov.in portal

---
This report was automatically generated by the Aatra AI system for law enforcement review and action.
Report generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} IST
        """.strip()
        
        return {
            "threat_id": threat_id,
            "report_content": report_content,
            "cybercrime_reference": f"AICMS_{datetime.now().strftime('%Y%m%d')}_{threat_id:06d}",
            "cybercrime_portal_url": "https://cybercrime.gov.in/Webform/report_abuse_social_media.aspx"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating report: {str(e)}")


@router.get("/status/{report_id}")
async def get_report_status(report_id: int, db: Session = Depends(get_db)):
    """
    Get status of submitted report
    """
    try:
        report = db.query(ThreatReport).filter(
            ThreatReport.id == report_id
        ).first()
        
        if not report:
            raise HTTPException(status_code=404, detail="Report not found")
        
        return {
            "id": report.id,
            "threat_id": report.threat_id,
            "status": report.status,
            "cybercrime_reference": report.cybercrime_reference,
            "reported_at": report.reported_at,
            "is_urgent": report.is_urgent
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching report status: {str(e)}")


@router.get("/list")
async def list_reports(
    limit: int = 50,
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    List all threat reports with optional filtering
    """
    try:
        query = db.query(ThreatReport).order_by(ThreatReport.reported_at.desc())
        
        if status:
            query = query.filter(ThreatReport.status == status)
        
        reports = query.limit(limit).all()
        
        return {
            "reports": [
                {
                    "id": report.id,
                    "threat_id": report.threat_id,
                    "status": report.status,
                    "cybercrime_reference": report.cybercrime_reference,
                    "reported_at": report.reported_at,
                    "is_urgent": report.is_urgent,
                    "reporter_contact": report.reporter_contact
                }
                for report in reports
            ],
            "total": len(reports)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching reports: {str(e)}")


@router.put("/status/{report_id}")
async def update_report_status(
    report_id: int,
    new_status: str,
    db: Session = Depends(get_db)
):
    """
    Update report status (for administrative use)
    """
    try:
        valid_statuses = ["submitted", "under_review", "resolved", "closed"]
        
        if new_status not in valid_statuses:
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid status. Valid options: {', '.join(valid_statuses)}"
            )
        
        report = db.query(ThreatReport).filter(
            ThreatReport.id == report_id
        ).first()
        
        if not report:
            raise HTTPException(status_code=404, detail="Report not found")
        
        report.status = new_status
        db.commit()
        
        return {
            "message": f"Report {report_id} status updated to {new_status}",
            "report_id": report_id,
            "new_status": new_status
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating report status: {str(e)}")